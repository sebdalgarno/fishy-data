[
  {
    "path": "posts/2021-04-14-movement-ecology/",
    "title": "Nathan's movement ecology paradigm",
    "description": "A reflection on how ideas in Nathan et al.'s 2008 paper might apply to the study of fish movement from acoustic telemetry data.",
    "author": [
      {
        "name": "Seb Dalgarno",
        "url": "https://github.com/sebdalgarno"
      }
    ],
    "date": "2021-04-15",
    "categories": [
      "Movement Ecology",
      "Acoustic Telemetry"
    ],
    "contents": "\nThe study of animal movement has advanced a lot in recent years. Nathan suggests that advancements in animal tracking technology, environmental monitoring, and analytical methods (i.e. from increased computational power) have led to a general shift from the study of population redistribution (Eularian approach) to the study of individuals (Lagrangian approach). This has enabled development of more complex models (e.g. state-space models for individual animal movement) and increased understanding of movement ecology. However, Nathan suggests that a common framework is necessary to unify several paradigms for animal movement (i.e. biomechanical, cognitive, random, optimality) that are operating parallel to one another.\nIn this attempt to unify the study of animal movement, Nathan’s paper suggests that there are four overarching questions:\nWhy do animals move?\nHow do animals move?\nWhen and where do animals move?\nWhat are the external factors driving animal movement?\nFollowing from this, Nathan suggests that animal movement is a function of internal state (why), motion capacity (how), navigation capacity (when and where) and external factors (abiotic and biotic). In this formulation, the motion process and navigation process are both impacted by current location, internal state (i.e. physiological or neurological state affecting motivation and readiness to move) and external factors. The movement propagation process is the realized movement resulting from the motion process, which is optionally affected by the navigation process.\nFramework for animal movement (Nathan et al. 2008)The result of this process is a lifetime movement track, which (at least partially) is observed by us. This track can be parsed into sub-units at various spatial and temporal scales. At a finer scale, movement paths can represent particular phenomena such as feeding or migrating. At even finer scales, movement steps might correspond to a few steps and a stop. Our ability to successfully identify movement phases depends on our ability to sample an individual’s movement (i.e. sampling frequency, duration and protocol).\nSpatiotemporal scales of sanimal movement (Nathan et al. 2008)A major challenge in the study of fish movement from acoustic telemetry is the limited sampling frequency and duration. Movement tracks from stationary receivers produce frequent and potentially large gaps in our knowledge of a fishes position in space and time. These gaps occur when a fish is moving or resting between receivers, has died or emigrated outside of the receiver array, or has not been detected despite actually being present due to detection error.\nSpecialized statistical methods such as state-space models are required to uncover the ecological process of interest (e.g. spatial position) from typically noisy observation data. Hidden Markov Models are a class of state-space models useful for uncovering a finite number of states of interest (e.g., resident vs transitory states), which could correspond to ‘movement paths’. Spatial capture-recapture models also have great potential for identifying distribution over time (i.e. as an animal’s activity center), taking into account detection error.\nIn acoustic telemetry studies we are typically interested landscape or population ecology questions (e.g. distribution, density, survival), which typically involve relating the internal state (e.g., motivations for moving such as feeding, spawning) to external factors (e.g., water temperature, discharge). Nathan places this type of research in the ‘optimality’ paradigm.\nHowever, the utility of Nathan’s framework is to force us to more comprehensively think about different drivers of fish movement in our models. In order to interpret our results, inform our study design, or place constraints on our model predictions, we need to consider motion capacity and navigation capacity of the animal being studied. This information can be drawn from biomechanical and cognitive paradigms or animal movement research. For example, understanding of motion capacity might inform us whether a fish is incapable of swimming in certain conditions (e.g., high flow, extreme water temperature). Understanding of navigation capacity might inform our understanding of what time of year a fish is going to migrate. One technology with great potential for improving our understanding the motion process are Data Storage Tags, which can measure physiological information as a fish moves (heart rate, muscle activity, acceleration) along with environmental conditions (e.g., water temperature).\nThrough advancements in technology (e.g., tracking technology, collection of physiological/environmental data), statistical methods (e.g., state-space models spatial capture-recapture), and incorporating our understanding of navigation and motion capacity of fish, there is great potential for Nathan’s framework to improve the study of fish movement from acoustic telemetry data.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-04-15T21:16:11-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-04-15-hmm/",
    "title": "Hidden Markov Models for fish movement",
    "description": "Exploring the use of HMMs for understanding fish movement and behaviour from capture-recapture and acoustic telemetry data.",
    "author": [
      {
        "name": "Seb Dalgarno",
        "url": "https://github.com/sebdalgarno"
      }
    ],
    "date": "2021-04-15",
    "categories": [
      "Stats",
      "Movement Ecology",
      "Hidden Markov Model"
    ],
    "contents": "\nWhat is a Hidden Markov Model?\nHidden Markov Models (HMM) can be used for ecological time series data to uncover hidden ecological states (McClintock et al. 2020). They do this by disentangling the observation process from the underlying (unobserved and hidden) state process. One important use for HMM is in movement ecology, where we can parse an animal’s movement path into several states that might correspond to behaviour (e.g., spawning, feeding), physiology, resource selection, etc.\nA HMM is a heirarchical model consisting of a model for the observation process (observation model) and a model for the state process (process model). It is a special case of state-space model with a finite number of possible states in the process model. The state process is not directyl observed; rather it is a hidden (or latent) variable. The observations (e.g., from telemetry or capture-recapture), which make up the observation model, are generated by the underlying state process but are ‘noisy’ measurements and are insufficient when considered alone to determine the state.\nHMMs have two major simplifying assumptions, one each for the state process and observation process. A major assumption for the state process is the Markov property - the probability of a state being active at time t is dependent on the state at time t - 1. A major assumption for the observation process is conditional independence - the probability distribution of an observation at time t is completely dependent on the state at time t (and is independent of any other states or observations).\nHow is a HMM specified?\nA HMM is specified with three major componenets:\nintitial distribution - a vector of probabilities for each state at the start of the time sequence.\nstate transition probabilities - a matrix of probabilities for switching from any state at time t to another state at time t + 1.\nstate-dependent distribution - probability distribution of an observation conditional on the state at time t. This depends on the form of the observed data, e.g. count data are poisson distributed, positive continous data may be gamm distributed, etc.\nA model can be fit using Maximum Likelihood or Bayesian methods.\nApplication of HMM to fish movement\nA HMM can be applied to a wide variety of questions about the existential, developmental and spatial states of fish (or other animals) at the level of individual, population, community or ecosystem. Here, let’s explore three potential applications for understanding fish movement/behaviour at the individual level from capture-recapture and acoustic telemetry data.\nSurvival\nWe can estimate surival (an existential question) using the Cormack-Jolly Seber model, with 2 states (alive and dead),where the probability of transitioning from dead to alive is set at 0.\nSpecification for a survival HMM (McClintock et al. 2020)Behavioral state (or movement phase)\nIn order to explore behaviours, we can extend the ‘alive’ state into multiple states, e.g. ‘alive and breeding’, ‘alive and non-breeding’. Disentangling multiple states from animal movement data can help to identify, for example, migratory phases, predation/feeding events, or hibernation/overwintering cycles. In these multi-state models of animal movement, observations are typically expressed as trajectories in 2-dimensional space, i.e., bivariate sequence of step-length (Euclidean distance) and turning angle. A two-state model could consist of ‘resident’ and ‘transient’, where movements in the ‘transient’ state correspond to longer step-lengths and more persistent turning angles. Step-length is typically considered to follow a gamma or Weibull probability distribution and turning angle is typically modeled with a von Mises or wrapped Cauchy distribution. The number of states in these types of models are typically not clear a priori and therefore need to be selected based on biological understanding and possibly, model selection. The state transition probabilities are also not predetermined, but rather are freely estimated by the model and are completely data-driven.\nSpecification for a multi-state behaviour HMM with bivariate observation process (McClintock et al. 2020)Spatial location\nWe can predict movement to or from specific spatial locations, where each state corresponds to a site (e.g. spawning vs overwintering site). This follows the same model specification as the above behaviour example, but the observations are univariate site locations (e.g. A, B, and 0, where A and B might correspond to a spawning site and overwintering site, respectively, and 0 is unknown location). State transition probabilities in this case are interpreted as probability of fidelity/dispersal. In this case, we could use the model to predict specific location at times in the observation sequence where location is unknown. Note, a state-space model or spatial capture-recapture model may be more appropriate in this case for prediction of continous location or activity center in 2-d space. \n\n\n\n",
    "preview": {},
    "last_modified": "2021-04-15T21:36:32-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-04-14-alfred/",
    "title": "Alfred + .Rproj",
    "description": "How to configure Alfred to search for .Rproj files",
    "author": [
      {
        "name": "Seb Dalgarno",
        "url": "https://github.com/sebdalgarno"
      }
    ],
    "date": "2021-04-14",
    "categories": [
      "Productivity",
      "RStudio"
    ],
    "contents": "\nTL;DR add dyn.ah62d4rv4ge81e6dwr7za to Preferences -> Features -> Default Results -> Advanced... panel to add .Rproj as a user-defined file type.\nOverview\nAlfred app is a productivity app (in their words) for MacOS 1 that does many many things. So far, I’ve just been using it’s search functionality and am finding it quite sweet indeed (think Spotlight, but better). The use case here is that I want to avoid using my mouse to search for various Rstudio .Rproj files (i.e. in Finder).\nHadley is god\nI first came across this tip from Hadley Wickham in this video - so you know it’s good.\nInstalling Alfred\nInstall Alfred from the website or with homebrew on the command line:\nbrew install --cask alfred\nConfiguring Alfred for .Rproj\nOpen Alfred and get into Preferences -> Features -> Default Results panel.\nAlfred1Click on Advanced... and add the following user-defined file type (by clicking +)\ndyn.ah62d4rv4ge81e6dwr7za\nAlfred1Keyboard shortcut\nI like to open Alfred with the keyboard shortcut Cmd-space instead of Spotlight. I followed the instructions here to do this.\nDone! Now open Alfred with Cmd-space and start typing in the name of a .Rproj file. Note you can add other file types for Alfred to look for (e.g. Scrivener projects). A final tip is that if you press space before typing the file name, Alfred will search all files.\nIf you are looking for more Mac productivity tips, check out this awesome Twitter thread\n\nSorry Windows users. But there are other apps for Windows that do similar things.↩︎\n",
    "preview": {},
    "last_modified": "2021-04-14T21:49:45-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-04-14-git-alias/",
    "title": "Git alias tricks",
    "description": "Using a git alias to commit and stage all files and other fancy tricks.",
    "author": [
      {
        "name": "Seb Dalgarno",
        "url": "https://github.com/sebdalgarno"
      }
    ],
    "date": "2021-04-14",
    "categories": [
      "Productivity",
      "RStudio"
    ],
    "contents": "\nTL;DR type git config --global alias.coa \"!git add -A && git commit -m\" in the command line. From now on, use git coa 'message here' to commit and stage all files!\nOverview\nFor years I have staged, committed and pushed changes with the RStudio Git interface.\n\nIt works! But I’ve realized that it’s much more efficient (and not hard!) to do from the command line. Check out this sweet resource by Jenny Bryan for more info on git with r.\nGit from the command line\nThis solution on stackoverflow suggests staging, committing and pushing all files by running the following in the command line:\ngit add -A && git commit -m \"rebuild site\"\ngit push\n\nGit alias\nReal productivity gains are made by using git aliases, which remove the need to type (and remember) full git commands. Let’s start with a simple example. To set up the alias git p for git push, we run in the command line:\ngit config --global alias.p \"push\"\nGoing back to our original use case, we can set up the alias git coa:\ngit config --global alias.coa \"!git add -A && git commit -m\"\nFrom now on, we can stage, commit and push all changes with two simple commands:\ngit coa 'rebuild site'\ngit p\nHere are some more useful aliases:\nCreate and checkout branch\ngit config --global alias.bc \"checkout -b\"\ngit bc some_new_branch\nDelete branch locally and remotely (from here)\ngit config --global alias.bd '!sh -c \"git branch -D $1 && git push origin :$1\" -'\n\ngit bd some_new_branch\nKeyboard shortcut to Terminal\nTo completely remove the need to use the mouse, I’ve set up a customized keyboard shortcut1 Cmd-3 to move the cursor to the RStudio Terminal. Check out this great tutorial on customizing keyboard shortcuts in RStudio. The advantage of using the RStudio terminal and not the MacOS Terminal app (or iterm2)2 is that it is automatically drilled down into the directory of your project.\n🎉🎉🎉\n\nI also use Cmd-1 to move cursor to script and Cmd-2 to move cursor to console.↩︎\nThese tips are for Mac users. I’m not sure how to do the above in Windows.↩︎\n",
    "preview": {},
    "last_modified": "2021-04-14T22:41:11-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-04-14-github-cli/",
    "title": "GitHub from the command line",
    "description": "Some tips and tricks for interacting with GitHub from the command line.",
    "author": [
      {
        "name": "Seb Dalgarno",
        "url": "https://github.com/sebdalgarno"
      }
    ],
    "date": "2021-04-14",
    "categories": [
      "Productivity",
      "GitHub"
    ],
    "contents": "\nOverview\nNavigating around the GitHub website between various repos/issues etc. is most definitely a time waster. I’ve decided to dig into the GitHub CLI. You can install it using homebrew with brew install gh and authorize it by running gh auth login in the command line (more info in this manual). Here’s a few things I found useful.\nDealing with issues\nList issues\nOnce you are drilled down into the project directory in the command line (or simply go to Terminal in an RStudio project), type the following:\ngh issue list\n\n# Showing 3 of 3 open issues in sebdalgarno/blog\n# \n# #6  add shortcodes                     about 1 day ago\n# #5  get RSS button working             about 1 day ago\n# #2  not rendering Rmd                  about 2 days ago\nView issues\nAs I’m writing this I realize that I’ve already solved #2. I’ll view it just to make sure.\ngh issue view 2\n\n# not rendering Rmd\n# Open • sebdalgarno opened about 2 days ago • 0 comments\n# \n# \n#   blogdown problem as other themes also not working                           \n# \n# \n# View this issue on GitHub: https://github.com/sebdalgarno/blog/issues/2\nClose issues\nYes! this was solved by moving to hugodown. I’ll close it.\ngh issue close 2\n# ✔ Closed issue #2 (not rendering Rmd)\nAs an aside, I use this neat little trick to close issues automatically by adding fixes #33 to a commit message (where 33 is the issue #). gh issue list is going to be super helpful to find the issue #.\nCreate issues\nI’ll create an issue to finish this post. I am being a little hard on myself here (since I’m already working on it!), but I really should finish this post.\ngh issue create --title \"Finish GitHub CLI post\" --body \"Seriously, do it.\"\n\n# Creating issue in sebdalgarno/blog\n# \n# https://github.com/sebdalgarno/blog/issues/9\nand confirm:\ngh issue list\n\n# Showing 3 of 3 open issues in sebdalgarno/blog\n#\n# #9  Finish GitHub CLI post             about 1 minute ago\n# #6  add shortcodes                     about 1 day ago\n# #5  get RSS button working             about 1 day ago\nDealing with pull requests\nCreate changes on a branch\nI’m going to create a branch called ‘fix_that_bug’ and fix that bug (you know, that one). Then I’ll commit and push those changes.\ngit cb fix_that_bug\n# Switched to a new branch \"fix_that_bug\"\n\ngit coa 'fixed it'\n[fix_that_bug 35457d9] fixed it\n 1 file changed, 3 insertions(+), 1 deletion(-)\n \ngit p\n{{% admonition tip tip %}} If the above git commands look strange that’s because they’re aliases! Check out my post on git alias for details. {{% /admonition %}}\nCreate pull request and merge\nNow I’ll create a pull request with gh,\ngh pr create --title \"fixed it\" --body \"good lord that took me 35 hours\" \n\n# ? Where should we push the 'fix_that_bug' branch? sebdalgarno/blog\n#\n# Creating pull request for fix_that_bug into master in sebdalgarno/blog\n#\n# remote: \n# remote: \n# To github.com:sebdalgarno/blog.git\n#  * [new branch]      HEAD -> fix_that_bug\n# Branch 'fix_that_bug' set up to track remote branch 'fix_that_bug' from 'origin'.\n# https://github.com/sebdalgarno/blog/pull/12\ncheck the diff (Ctrl-c to quit process)\ngh pr diff 12\nmerge it,\ngh pr merge 12\n# ? What merge method would you like to use? Create a merge commit\n# ? Delete the branch locally and on GitHub? Yes\n# ? Submit? Yes\n# ✔ Merged pull request #12 (fixed it)\n# ✔ Deleted branch fix_that_bug and switched to branch master\nand pull into local master (or main) branch.\ngit pull\nThat’s it for now!\nOh ya one more thing\ngh issue close 9\n# ✔ Closed issue #9 (Finish GitHub CLI post)\n{{% admonition tip tip %}} See the full list of commands and examples and some resources for setting up scripts and aliases. {{% /admonition %}}\n\n\n\n",
    "preview": {},
    "last_modified": "2021-04-14T22:44:21-07:00",
    "input_file": {}
  }
]
